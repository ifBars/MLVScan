using MLVScan.Models;
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using Mono.Cecil;
using Mono.Cecil.Cil;
using System.Reflection;

namespace MLVScan.Services
{
    public class PromptGeneratorService
    {
        private readonly ScanConfig _config;
        private readonly MelonLoader.MelonLogger.Instance _logger;
        
        public PromptGeneratorService(ScanConfig config, MelonLoader.MelonLogger.Instance logger)
        {
            _config = config ?? throw new ArgumentNullException(nameof(config));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public string GeneratePrompt(string modPath, List<ScanFinding> findings)
        {
            if (findings == null || !findings.Any())
                return "No suspicious findings to analyze.";

            var modName = Path.GetFileName(modPath);
            var sb = new StringBuilder();

            // Title and context section
            sb.AppendLine("# Mod Security Analysis Request");
            sb.AppendLine();
            sb.AppendLine("I need to determine if the following mod is malicious or a false positive. Below is a security scan report generated by MLVScan (a security tool for MelonLoader mods).");
            sb.AppendLine();

            // Mod information
            sb.AppendLine("## Mod Information");
            sb.AppendLine($"- **Filename**: {modName}");
            sb.AppendLine($"- **Scan Date**: {DateTime.Now}");
            sb.AppendLine($"- **Total Suspicious Patterns**: {findings.Count}");
            sb.AppendLine();

            // Severity breakdown
            var severityCounts = findings
                .GroupBy(f => f.Severity)
                .OrderByDescending(g => GetSeverityRank(g.Key))
                .ToDictionary(g => g.Key, g => g.Count());

            sb.AppendLine("## Severity Breakdown");
            foreach (var severityCount in severityCounts)
            {
                sb.AppendLine($"- **{FormatSeverityLabel(severityCount.Key)}**: {severityCount.Value} issue(s)");
            }
            sb.AppendLine();

            // Detailed findings with code blocks
            sb.AppendLine("## Detailed Findings");
            var groupedFindings = findings
                .GroupBy(f => f.Description)
                .ToDictionary(g => g.Key, g => g.ToList());

            var (methodDecompilations, classStructures) = ExtractCodeBlocks(modPath, findings);

            foreach (var group in groupedFindings)
            {
                sb.AppendLine($"### {group.Key}");
                sb.AppendLine($"- **Severity**: {group.Value[0].Severity}");
                sb.AppendLine($"- **Occurrences**: {group.Value.Count}");
                sb.AppendLine("- **Locations & Snippets**:");
                
                foreach (var finding in group.Value.Take(5)) // Show details for up to 5 instances
                {
                    sb.AppendLine($"  - **Location**: {finding.Location}");
                    
                    if (!string.IsNullOrEmpty(finding.CodeSnippet))
                    {
                        sb.AppendLine("    **IL Snippet (Exact location of suspicious call)**:");
                        sb.AppendLine("    ```");
                        foreach (var line in finding.CodeSnippet.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries))
                        {
                            sb.AppendLine($"    {line}");
                        }
                        sb.AppendLine("    ```");
                    }
                    
                    if (methodDecompilations.TryGetValue(finding.Location, out var csharpDecompiledMethod) && !string.IsNullOrWhiteSpace(csharpDecompiledMethod))
                    {
                        sb.AppendLine("    **Attempted C# Decompilation (Entire Method Context & Type Info)**:");
                        sb.AppendLine("    ```csharp");
                        foreach (var line in csharpDecompiledMethod.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries))
                        {
                            sb.AppendLine($"    {line}"); // Assuming csharpDecompiledMethod is already formatted with necessary newlines
                        }
                        sb.AppendLine("    ```");
                    }

                    if (classStructures.TryGetValue(finding.Location, out var classStructureString) && !string.IsNullOrWhiteSpace(classStructureString))
                    {
                        sb.AppendLine("    **Surrounding Class Structure (Member Signatures Only)**:");
                        sb.AppendLine("    ```csharp");
                         foreach (var line in classStructureString.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries))
                        {
                            sb.AppendLine($"    {line}");
                        }
                        sb.AppendLine("    ```");
                    }
                    sb.AppendLine(); 
                }
                
                if (group.Value.Count > 5)
                {
                    sb.AppendLine($"  - *And {group.Value.Count - 5} more occurrences (details omitted for brevity)*");
                }
                sb.AppendLine();
            }

            // Assembly metadata analysis
            var assemblyInfo = ExtractAssemblyMetadata(modPath);
            if (!string.IsNullOrEmpty(assemblyInfo))
            {
                sb.AppendLine("## Assembly Metadata");
                sb.AppendLine(assemblyInfo);
                sb.AppendLine();
            }

            // Analysis request
            sb.AppendLine("## Request");
            sb.AppendLine("Based on this scan report and code analysis, please help me determine:");
            sb.AppendLine("1. Is this mod likely to be malicious or is it a false positive?");
            sb.AppendLine("2. If potentially malicious, what specific security risks does it pose?");
            sb.AppendLine("3. What is the intent of the suspicious code? Is there a benign explanation?");
            sb.AppendLine("4. What further actions should I take? (Whitelist it, delete it, report it, etc.)");
            sb.AppendLine();
            sb.AppendLine("Please explain your reasoning with reference to the specific code patterns and provide context about:");
            sb.AppendLine("- Whether these patterns are common in legitimate mods or game utilities");
            sb.AppendLine("- Alternative explanations for the suspicious patterns");
            sb.AppendLine("- Your confidence level in the assessment");
            sb.AppendLine();
            sb.AppendLine("Important context: This is a mod for a game using MelonLoader (a mod loading framework). Legitimate mods generally don't need to use system-level APIs like shell execution, registry access, etc.");

            return sb.ToString();
        }

        private Tuple<Dictionary<string, string>, Dictionary<string, string>> ExtractCodeBlocks(string modPath, List<ScanFinding> findings)
        {
            var methodCodeBlocks = new Dictionary<string, string>();
            var classStructures = new Dictionary<string, string>();
            
            try
            {
                if (!File.Exists(modPath))
                    return Tuple.Create(methodCodeBlocks, classStructures);

                var readerParameters = new ReaderParameters
                {
                    ReadWrite = false,
                    InMemory = true,
                    ReadSymbols = false
                };

                using var assembly = AssemblyDefinition.ReadAssembly(modPath, readerParameters);
                
                var suspiciousStrings = new Dictionary<string, List<string>>();
                foreach (var module in assembly.Modules)
                {
                    foreach (var type in module.Types)
                    {
                        CollectSuspiciousStrings(type, suspiciousStrings);
                    }
                }
                
                if (suspiciousStrings.Any())
                {
                    var sbStrings = new StringBuilder();
                    sbStrings.AppendLine("// Notable string literals found in the assembly:");
                    sbStrings.AppendLine();
                    
                    foreach (var category in suspiciousStrings.Keys.OrderBy(k => k))
                    {
                        sbStrings.AppendLine($"// Potential {category}:");
                        foreach (var str in suspiciousStrings[category].Take(10))
                        {
                            sbStrings.AppendLine($"//   \"{EscapeStringForCode(str)}\"");
                        }
                        
                        if (suspiciousStrings[category].Count > 10)
                        {
                            sbStrings.AppendLine($"//   ... and {suspiciousStrings[category].Count - 10} more");
                        }
                        sbStrings.AppendLine();
                    }
                    
                    methodCodeBlocks["SuspiciousStrings"] = sbStrings.ToString();
                }
                
                foreach (var finding in findings)
                {
                    try
                    {
                        var location = finding.Location;
                        if (location == "Assembly scanning" || !location.Contains("."))
                            continue;
                            
                        var methodOffset = string.Empty;
                        string typeNameFromFinding;
                        string methodNameFromFinding;

                        if (location.Contains(":")) // Format: Namespace.Type.Method:Offset
                        {
                            var parts = location.Split(':');
                            var fullMethodPath = parts[0];
                            methodOffset = parts[1];
                            var lastDotIndex = fullMethodPath.LastIndexOf('.');
                            if (lastDotIndex <= 0) continue;
                            typeNameFromFinding = fullMethodPath.Substring(0, lastDotIndex);
                            methodNameFromFinding = fullMethodPath.Substring(lastDotIndex + 1);
                        }
                        else // Format: Namespace.Type.Method (likely a DllImport)
                        {
                            var lastDotIndex = location.LastIndexOf('.');
                            if (lastDotIndex <= 0) continue;
                            typeNameFromFinding = location.Substring(0, lastDotIndex);
                            methodNameFromFinding = location.Substring(lastDotIndex + 1);
                        }
                        
                        var typeDefinition = FindType(assembly.MainModule, typeNameFromFinding);
                        if (typeDefinition == null) continue;
                        
                        // Generate and store class structure (once per type for efficiency, mapped by finding location)
                        if (!classStructures.ContainsKey(finding.Location) || classStructures[finding.Location] == string.Empty) // Check to avoid recomputing for same type via different findings if keying by typeName
                        {
                             // We want to store it per finding location for easy lookup in GeneratePrompt
                             classStructures[finding.Location] = GenerateClassStructure(typeDefinition, methodNameFromFinding);
                        }

                        var methodDefinition = typeDefinition.Methods.FirstOrDefault(m => m.Name == methodNameFromFinding);
                        // For DllImports, methodDefinition might be what we need, or it might be better to rely on the IL snippet.
                        // For regular method calls, methodDefinition is key.
                        if (methodDefinition == null) // Could be a DllImport scenario where the finding.Location is the method itself
                        {
                            // If it's a DllImport, the IL snippet is primary. DecompileMethod might not be useful.
                            // We still want class context if possible.
                            if (!methodCodeBlocks.ContainsKey(finding.Location)) // Avoid overwriting if already processed (e.g. from SuspiciousStrings)
                            {
                                 methodCodeBlocks[finding.Location] = $"// DllImport or external method: {finding.Location}. Primary context is the IL snippet and class structure.";
                            }
                            continue; 
                        }
                        
                        if (!methodDefinition.HasBody && !methodDefinition.IsAbstract) // Abstract methods are fine, but others need a body
                        {
                             if (!methodCodeBlocks.ContainsKey(finding.Location))
                             {
                                methodCodeBlocks[finding.Location] = $"// Method {methodNameFromFinding} has no body or is abstract.";
                             }
                             continue;
                        }

                        var codeBlock = DecompileMethod(methodDefinition); // This is the existing method decompilation
                        if (!string.IsNullOrEmpty(codeBlock))
                        {
                            var contextBuilder = new StringBuilder();
                            contextBuilder.AppendLine($"// Context: Method is part of {typeDefinition.FullName}");
                            if (typeDefinition.HasCustomAttributes)
                            {
                                contextBuilder.AppendLine("// Type attributes:");
                                foreach (var attr in typeDefinition.CustomAttributes.Take(5)) { contextBuilder.AppendLine($"// - {attr.AttributeType.Name}"); }
                                if (typeDefinition.CustomAttributes.Count > 5) { contextBuilder.AppendLine($"// - ...and {typeDefinition.CustomAttributes.Count - 5} more");}
                            }
                            if (typeDefinition.BaseType != null && typeDefinition.BaseType.FullName != "System.Object") { contextBuilder.AppendLine($"// Inherits from: {typeDefinition.BaseType.FullName}");}
                            var relatedMethods = FindRelatedSuspiciousMethods(typeDefinition, methodDefinition);
                            if (relatedMethods.Any())
                            {
                                contextBuilder.AppendLine("// Other suspicious methods in this class (names only):");
                                foreach (var relatedMethod in relatedMethods.Take(3)) { contextBuilder.AppendLine($"// - {relatedMethod.Name}");}
                                if (relatedMethods.Count > 3) { contextBuilder.AppendLine($"// - ...and {relatedMethods.Count - 3} more");}
                            }
                            contextBuilder.AppendLine();
                            contextBuilder.AppendLine($"// Finding Description: {finding.Description}");
                            contextBuilder.AppendLine($"// Severity: {finding.Severity}");
                            contextBuilder.AppendLine();
                            
                            methodCodeBlocks[finding.Location] = contextBuilder.ToString() + codeBlock;
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.Error($"Failed to extract code for {finding.Location}: {ex.Message}");
                        methodCodeBlocks[finding.Location] = $"// Error extracting detailed code for {finding.Location}: {ex.Message}";
                    }
                }
                
                if (assembly.MainModule.Resources.Any())
                {
                    var sbResources = new StringBuilder();
                    sbResources.AppendLine("// Assembly Resources (could contain hidden payloads):");
                    
                    foreach (var resource in assembly.MainModule.Resources.Take(20))
                    {
                        sbResources.AppendLine($"//   {resource.Name} - {GetResourceTypeName(resource)}");
                    }
                    
                    if (assembly.MainModule.Resources.Count > 20)
                    {
                        sbResources.AppendLine($"//   ...and {assembly.MainModule.Resources.Count - 20} more resources");
                    }
                    
                    methodCodeBlocks["Assembly.Resources"] = sbResources.ToString();
                }
            }
            catch (Exception ex)
            {
                _logger.Error($"Failed to extract code blocks from {modPath}: {ex.Message}");
            }
            
            return Tuple.Create(methodCodeBlocks, classStructures);
        }
        
        private void CollectSuspiciousStrings(TypeDefinition type, Dictionary<string, List<string>> suspiciousStrings)
        {
            // Process this type
            foreach (var method in type.Methods)
            {
                if (!method.HasBody) continue;
                
                foreach (var instruction in method.Body.Instructions)
                {
                    if (instruction.OpCode.Name == "ldstr" && instruction.Operand is string str)
                    {
                        // Categorize suspicious strings
                        if (IsSuspiciousString(str, out var category))
                        {
                            if (!suspiciousStrings.ContainsKey(category))
                            {
                                suspiciousStrings[category] = new List<string>();
                            }
                            
                            if (!suspiciousStrings[category].Contains(str))
                            {
                                suspiciousStrings[category].Add(str);
                            }
                        }
                    }
                }
            }
            
            // Process nested types recursively
            foreach (var nestedType in type.NestedTypes)
            {
                CollectSuspiciousStrings(nestedType, suspiciousStrings);
            }
        }
        
        private bool IsSuspiciousString(string value, out string category)
        {
            if (string.IsNullOrEmpty(value))
            {
                category = string.Empty;
                return false;
            }
            
            // Check for potential Base64 encoded content
            if (value.Length > 20 && IsLikelyBase64(value))
            {
                category = "Base64 encoded data";
                return true;
            }
            
            // Check for URLs or network addresses
            if (value.StartsWith("http://") || value.StartsWith("https://") || 
                value.StartsWith("ftp://") || value.StartsWith("ws://"))
            {
                category = "URL";
                return true;
            }
            
            if (value.Contains(".exe") || value.Contains(".dll") || value.Contains(".bat") || 
                value.Contains(".cmd") || value.Contains(".ps1") || value.Contains(".vbs"))
            {
                category = "executable file reference";
                return true;
            }
            
            // Check for IP addresses
            if (IsLikelyIPAddress(value))
            {
                category = "IP address";
                return true;
            }
            
            // Check for registry paths
            if (value.StartsWith("HKEY_") || value.Contains("\\Software\\") || 
                value.Contains("\\Microsoft\\") || value.Contains("\\System\\"))
            {
                category = "registry path";
                return true;
            }
            
            // Check for commands that might be executed
            if (value.StartsWith("cmd ") || value.StartsWith("powershell ") || 
                value.Contains(" /c ") || value.Contains(" /k "))
            {
                category = "command line";
                return true;
            }
            
            // Check for cryptographic indicators
            if (value.Contains("encrypt") || value.Contains("decrypt") || 
                value.Contains("aes") || value.Contains("rsa") || value.Contains("md5") || 
                value.Contains("sha") || value.Contains("hash"))
            {
                category = "cryptographic reference";
                return true;
            }
            
            // Check for potentially malicious domains
            if ((value.Contains(".") && !value.Contains(" ") && !value.Contains("\\") && 
                 !value.EndsWith(".cs") && !value.EndsWith(".txt") && value.Length > 5) || 
                value.Contains("pastebin") || value.Contains("discord") || 
                value.Contains("webhook"))
            {
                category = "domain or web service";
                return true;
            }
            
            category = string.Empty;
            return false;
        }
        
        private bool IsLikelyBase64(string value)
        {
            // Simple heuristic for base64 encoded content
            if (value.Length % 4 != 0) return false;
            
            // Check for common base64 characters
            foreach (var c in value)
            {
                if (!((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || 
                      (c >= '0' && c <= '9') || c == '+' || c == '/' || c == '='))
                {
                    return false;
                }
            }
            
            // If it's longer than 20 chars and has a good distribution of characters, likely base64
            return value.Length > 20 && value.Any(c => c >= 'A' && c <= 'Z') && 
                   value.Any(c => c >= 'a' && c <= 'z') && value.Any(c => c >= '0' && c <= '9');
        }
        
        private bool IsLikelyIPAddress(string value)
        {
            // Simple check for IP v4 or v6 address patterns
            var ipv4Pattern = @"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}";
            var ipv6Pattern = @"^[0-9a-fA-F:]+";
            
            return System.Text.RegularExpressions.Regex.IsMatch(value, ipv4Pattern) || 
                   System.Text.RegularExpressions.Regex.IsMatch(value, ipv6Pattern);
        }
        
        private string GetResourceTypeName(Mono.Cecil.Resource resource)
        {
            if (resource is Mono.Cecil.EmbeddedResource embedded)
            {
                // Try to determine what kind of data this might be
                using var stream = embedded.GetResourceStream();
                if (stream.Length > 0)
                {
                    var buffer = new byte[Math.Min(stream.Length, 16)];
                    stream.Read(buffer, 0, buffer.Length);
                    
                    // Check file signatures to identify binary content
                    if (buffer.Length >= 2 && buffer[0] == 0x4D && buffer[1] == 0x5A)
                    {
                        return "PE File/DLL (MZ header)";
                    }
                    if (buffer.Length >= 4 && buffer[0] == 0x7F && buffer[1] == 0x45 && 
                        buffer[2] == 0x4C && buffer[3] == 0x46)
                    {
                        return "ELF Binary";
                    }
                    if (buffer.Length >= 4 && buffer[0] == 0x50 && buffer[1] == 0x4B && 
                        buffer[2] == 0x03 && buffer[3] == 0x04)
                    {
                        return "ZIP Archive";
                    }
                    if (buffer.Length >= 2 && buffer[0] == 0xFF && buffer[1] == 0xD8)
                    {
                        return "JPEG Image";
                    }
                    if (buffer.Length >= 3 && buffer[0] == 0x47 && buffer[1] == 0x49 && 
                        buffer[2] == 0x46)
                    {
                        return "GIF Image";
                    }
                    if (buffer.Length >= 4 && ((buffer[0] == 0x89 && buffer[1] == 0x50 && 
                                                buffer[2] == 0x4E && buffer[3] == 0x47) ||
                                               (buffer[0] == 0x42 && buffer[1] == 0x4D)))
                    {
                        return "PNG or BMP Image";
                    }
                    
                    return $"Binary data ({stream.Length} bytes)";
                }
                return "Empty resource";
            }
            return resource.ResourceType.ToString();
        }
        
        private List<MethodDefinition> FindRelatedSuspiciousMethods(TypeDefinition type, MethodDefinition currentMethod)
        {
            var result = new List<MethodDefinition>();
            
            foreach (var method in type.Methods)
            {
                if (method == currentMethod || !method.HasBody) continue;
                
                foreach (var instruction in method.Body.Instructions)
                {
                    if ((instruction.OpCode.Name == "call" || instruction.OpCode.Name == "callvirt" || 
                         instruction.OpCode.Name == "newobj") && 
                        instruction.Operand is MethodReference methodRef && 
                        IsSuspiciousMethodCall(methodRef))
                    {
                        result.Add(method);
                        break; // Add each method only once
                    }
                }
            }
            
            return result;
        }
        
        private TypeDefinition FindType(ModuleDefinition module, string fullTypeName)
        {
            foreach (var type in module.Types)
            {
                if (type.FullName == fullTypeName)
                    return type;
                    
                // Check nested types
                var nestedType = FindNestedType(type, fullTypeName);
                if (nestedType != null)
                    return nestedType;
            }
            
            return null;
        }
        
        private TypeDefinition FindNestedType(TypeDefinition parentType, string fullTypeName)
        {
            foreach (var nestedType in parentType.NestedTypes)
            {
                if (nestedType.FullName == fullTypeName)
                    return nestedType;
                    
                var foundType = FindNestedType(nestedType, fullTypeName);
                if (foundType != null)
                    return foundType;
            }
            
            return null;
        }
        
        private string DecompileMethod(MethodDefinition method)
        {
            if (!method.HasBody)
                return string.Empty;
                
            var sb = new StringBuilder();
            
            // Add method signature
            sb.AppendLine($"{GetMethodVisibility(method)} {method.ReturnType.Name} {method.Name}({GetMethodParameters(method)})");
            sb.AppendLine("{");
            
            // Attempt to reconstruct high-level C# code from IL instructions
            var reconstructedCode = ReconstructCode(method);
            if (!string.IsNullOrEmpty(reconstructedCode))
            {
                sb.AppendLine(reconstructedCode);
            }
            else
            {
                // Fallback to a more detailed version of IL instructions
                sb.AppendLine("    // Method body:");
                
                // Track if we're inside a try/catch block
                var exceptionHandlers = method.Body.ExceptionHandlers.ToList();
                var handlerStarts = exceptionHandlers.Select(h => h.HandlerStart.Offset).ToHashSet();
                var handlerEnds = exceptionHandlers.Select(h => h.HandlerEnd?.Offset ?? int.MaxValue).ToHashSet();
                var tryStarts = exceptionHandlers.Select(h => h.TryStart.Offset).ToHashSet();
                var tryEnds = exceptionHandlers.Select(h => h.TryEnd?.Offset ?? int.MaxValue).ToHashSet();
                
                bool inTryBlock = false;
                bool inCatchBlock = false;
                
                // Track variable and parameter usage
                var variables = method.Body.Variables.ToList();
                var parameters = method.Parameters.ToList();
                
                // Group instructions by sequence
                var instructions = method.Body.Instructions.ToList();
                for (int i = 0; i < instructions.Count; i++)
                {
                    var instruction = instructions[i];
                    
                    // Check for try/catch block boundaries
                    if (tryStarts.Contains(instruction.Offset) && !inTryBlock)
                    {
                        sb.AppendLine("    try {");
                        inTryBlock = true;
                    }
                    
                    if (handlerStarts.Contains(instruction.Offset) && !inCatchBlock)
                    {
                        var handler = exceptionHandlers.FirstOrDefault(h => h.HandlerStart.Offset == instruction.Offset);
                        sb.AppendLine("    } catch (" + (handler?.CatchType?.Name ?? "Exception") + ") {");
                        inTryBlock = false;
                        inCatchBlock = true;
                    }
                    
                    if ((tryEnds.Contains(instruction.Offset) && inTryBlock) || 
                        (handlerEnds.Contains(instruction.Offset) && inCatchBlock))
                    {
                        sb.AppendLine("    }");
                        inTryBlock = false;
                        inCatchBlock = false;
                    }
                    
                    // Format the current instruction with enhanced context
                    var line = FormatInstructionWithContext(instruction, i, instructions, variables, parameters);
                    if (!string.IsNullOrEmpty(line))
                    {
                        // Add indentation based on nesting
                        string indent = "    ";
                        if (inTryBlock || inCatchBlock) 
                            indent += "    ";
                        
                        sb.AppendLine($"{indent}{line}");
                    }
                }
                
                // Close any open blocks
                if (inTryBlock || inCatchBlock)
                    sb.AppendLine("    }");
            }
            
            // Add context about method parameters and local variables
            if (method.Parameters.Count > 0)
            {
                sb.AppendLine();
                sb.AppendLine("    // Method parameters:");
                foreach (var parameter in method.Parameters)
                {
                    sb.AppendLine($"    // {parameter.ParameterType.FullName} {parameter.Name}");
                }
            }
            
            if (method.Body.Variables.Count > 0)
            {
                sb.AppendLine();
                sb.AppendLine("    // Local variables:");
                foreach (var variable in method.Body.Variables)
                {
                    sb.AppendLine($"    // {variable.VariableType.FullName} var_{variable.Index}");
                }
            }
            
            // Show references to suspicious APIs
            var suspiciousApis = FindSuspiciousApiCalls(method);
            if (suspiciousApis.Any())
            {
                sb.AppendLine();
                sb.AppendLine("    // Suspicious API calls:");
                foreach (var api in suspiciousApis)
                {
                    sb.AppendLine($"    // {api}");
                }
            }
            
            sb.AppendLine("}");
            
            return sb.ToString();
        }
        
        private string ReconstructCode(MethodDefinition method)
        {
            var sb = new StringBuilder();
            
            try
            {
                // This is a simplified attempt to convert IL to C# code
                // It won't handle all cases, but will try to provide more readable output
                var instructions = method.Body.Instructions.ToList();
                
                for (int i = 0; i < instructions.Count; i++)
                {
                    var instruction = instructions[i];
                    
                    // Look for common patterns and convert them to C# syntax
                    if (instruction.OpCode.Name == "call" || instruction.OpCode.Name == "callvirt")
                    {
                        if (instruction.Operand is MethodReference methodRef)
                        {
                            // Extract method call information
                            string methodCall = GetMethodCallRepresentation(methodRef, instructions, i);
                            if (!string.IsNullOrEmpty(methodCall))
                            {
                                sb.AppendLine($"    {methodCall};");
                            }
                        }
                    }
                    else if (instruction.OpCode.Name == "newobj" && instruction.Operand is MethodReference ctorRef)
                    {
                        // Extract object creation
                        sb.AppendLine($"    new {ctorRef.DeclaringType.Name}(...);");
                    }
                    else if (instruction.OpCode.Name == "ldstr" && instruction.Operand is string stringValue)
                    {
                        // Show string literals
                        sb.AppendLine($"    // String: \"{EscapeStringForCode(stringValue)}\"");
                    }
                }
                
                // If we couldn't reconstruct anything meaningful, return empty
                if (sb.Length == 0)
                    return string.Empty;
                    
                return sb.ToString();
            }
            catch
            {
                // If reconstruction fails, return empty to fall back to IL display
                return string.Empty;
            }
        }
        
        private string EscapeStringForCode(string value)
        {
            if (string.IsNullOrEmpty(value))
                return value;
                
            return value.Replace("\"", "\\\"")
                        .Replace("\r", "\\r")
                        .Replace("\n", "\\n")
                        .Replace("\t", "\\t");
        }
        
        private string GetMethodCallRepresentation(MethodReference methodRef, List<Instruction> instructions, int currentIndex)
        {
            var methodName = methodRef.Name;
            var typeName = methodRef.DeclaringType.Name;
            
            // Known suspicious method patterns to highlight
            if (methodName.Contains("Process") && methodName.Contains("Start"))
            {
                return $"System.Diagnostics.Process.Start(...) // Executes external process";
            }
            
            if (methodName.Contains("Load") && typeName.Contains("Assembly"))
            {
                return $"Assembly.{methodName}(...) // Dynamically loads code";
            }
            
            if ((methodName.Contains("FromBase64") || methodName.Contains("GetString")) && typeName.Contains("Convert"))
            {
                // Look back for string parameters
                string base64Value = "...";
                for (int i = currentIndex - 1; i >= Math.Max(0, currentIndex - 5); i--)
                {
                    if (instructions[i].OpCode.Name == "ldstr" && instructions[i].Operand is string)
                    {
                        base64Value = instructions[i].Operand.ToString();
                        if (base64Value.Length > 20)
                            base64Value = base64Value.Substring(0, 17) + "...";
                        break;
                    }
                }
                
                return $"Convert.{methodName}(\"{base64Value}\") // Decodes Base64 data";
            }
            
            if (methodName.Contains("RegOpenKey") || methodName.Contains("RegCreateKey") || 
                methodName.Contains("Registry") && (methodName.Contains("Get") || methodName.Contains("Set")))
            {
                return $"{typeName}.{methodName}(...) // Registry manipulation";
            }
            
            if (methodName.Contains("CreateFile") || methodName.Contains("WriteFile") || methodName.Contains("ReadFile"))
            {
                return $"{typeName}.{methodName}(...) // File system operation";
            }
            
            if (methodName.Contains("Socket") || methodName.Contains("Connect") || 
                methodName.Contains("Send") || methodName.Contains("Receive"))
            {
                return $"{typeName}.{methodName}(...) // Network communication";
            }
            
            // Default representation
            return $"{typeName}.{methodName}(...)";
        }
        
        private string FormatInstructionWithContext(Instruction instruction, int index, 
            List<Instruction> allInstructions, List<VariableDefinition> variables, List<ParameterDefinition> parameters)
        {
            var opCode = instruction.OpCode.Name;
            
            // Skip nop instructions to reduce noise
            if (opCode == "nop")
                return string.Empty;
                
            var result = new StringBuilder();
            
            // Add instruction offset as comment for reference
            result.Append($"/* {instruction.Offset:X4} */ ");
            
            // Format operand with enhanced context
            if (instruction.Operand is MethodReference methodRef)
            {
                // For method calls, provide more context
                result.Append($"{opCode} {methodRef.DeclaringType.FullName}.{methodRef.Name}()");
                
                // Add parameter details if available
                if (methodRef.Parameters.Count > 0)
                {
                    result.Append($" // Takes: {string.Join(", ", methodRef.Parameters.Select(p => p.ParameterType.Name))}");
                }
                
                // Add special comments for known suspicious calls
                if (IsSuspiciousMethodCall(methodRef))
                {
                    result.Append($" // SUSPICIOUS: {GetSuspiciousMethodDescription(methodRef)}");
                }
            }
            else if (instruction.Operand is TypeReference typeRef)
            {
                result.Append($"{opCode} {typeRef.FullName}");
            }
            else if (instruction.Operand is FieldReference fieldRef)
            {
                result.Append($"{opCode} {fieldRef.DeclaringType.Name}.{fieldRef.Name}");
            }
            else if (instruction.Operand is VariableDefinition varDef)
            {
                // For local variables, include the variable type
                var variableType = varDef.VariableType.Name;
                result.Append($"{opCode} V_{varDef.Index} /* {variableType} */");
            }
            else if (instruction.Operand is ParameterDefinition paramDef)
            {
                // For parameters, include the parameter type
                var paramType = paramDef.ParameterType.Name;
                result.Append($"{opCode} {paramDef.Name} /* {paramType} */");
            }
            else if (instruction.Operand is string stringValue)
            {
                // For strings, truncate if too long and escape special characters
                var displayValue = stringValue;
                if (displayValue.Length > 50)
                    displayValue = displayValue.Substring(0, 47) + "...";
                    
                result.Append($"{opCode} \"{EscapeStringForCode(displayValue)}\"");
            }
            else if (instruction.Operand is Instruction targetInstruction)
            {
                // For branch instructions, show the target offset
                result.Append($"{opCode} IL_{targetInstruction.Offset:X4}");
            }
            else
            {
                // Default case
                var operandText = instruction.Operand?.ToString() ?? string.Empty;
                result.Append($"{opCode} {operandText}");
            }
            
            return result.ToString();
        }
        
        private bool IsSuspiciousMethodCall(MethodReference methodRef)
        {
            var typeName = methodRef.DeclaringType.FullName;
            var methodName = methodRef.Name;
            
            return 
                // Process start
                (typeName.Contains("Process") && methodName.Contains("Start")) ||
                
                // Dynamic assembly loading
                (typeName.Contains("Assembly") && 
                 (methodName.Contains("Load") || methodName.Contains("LoadFrom") || methodName.Contains("LoadFile"))) ||
                
                // Base64 decoding
                (typeName.Contains("Convert") && methodName.Contains("FromBase64")) ||
                
                // Registry operations
                ((typeName.Contains("Registry") || methodName.Contains("Reg")) && 
                 (methodName.Contains("CreateKey") || methodName.Contains("OpenKey") || 
                  methodName.Contains("SetValue") || methodName.Contains("GetValue"))) ||
                  
                // Shell execute
                (typeName.Contains("Shell32") || methodName.Contains("ShellExecute")) ||
                
                // Network operations
                ((typeName.Contains("Socket") || typeName.Contains("Http") || typeName.Contains("Tcp") || 
                  typeName.Contains("Web") || typeName.Contains("Net")) &&
                 (methodName.Contains("Connect") || methodName.Contains("Send") || 
                  methodName.Contains("Download") || methodName.Contains("Upload")));
        }
        
        private string GetSuspiciousMethodDescription(MethodReference methodRef)
        {
            var typeName = methodRef.DeclaringType.FullName;
            var methodName = methodRef.Name;
            
            if (typeName.Contains("Process") && methodName.Contains("Start"))
                return "Executes external programs";
                
            if (typeName.Contains("Assembly") && 
                (methodName.Contains("Load") || methodName.Contains("LoadFrom") || methodName.Contains("LoadFile")))
                return "Dynamically loads code which could be malicious";
                
            if (typeName.Contains("Convert") && methodName.Contains("FromBase64"))
                return "Decodes potentially obfuscated data";
                
            if ((typeName.Contains("Registry") || methodName.Contains("Reg")) && 
                (methodName.Contains("CreateKey") || methodName.Contains("OpenKey") || 
                 methodName.Contains("SetValue") || methodName.Contains("GetValue")))
                return "Manipulates system registry which can persist malware";
                
            if (typeName.Contains("Shell32") || methodName.Contains("ShellExecute"))
                return "Executes system commands";
                
            if ((typeName.Contains("Socket") || typeName.Contains("Http") || typeName.Contains("Tcp") || 
                 typeName.Contains("Web") || typeName.Contains("Net")) &&
                (methodName.Contains("Connect") || methodName.Contains("Send") || 
                 methodName.Contains("Download") || methodName.Contains("Upload")))
                return "Performs network operations that could exfiltrate data or download malware";
                
            return "Potentially suspicious behavior";
        }
        
        private List<string> FindSuspiciousApiCalls(MethodDefinition method)
        {
            var result = new List<string>();
            
            foreach (var instruction in method.Body.Instructions)
            {
                if ((instruction.OpCode.Name == "call" || instruction.OpCode.Name == "callvirt" || 
                     instruction.OpCode.Name == "newobj") && 
                    instruction.Operand is MethodReference methodRef && 
                    IsSuspiciousMethodCall(methodRef))
                {
                    result.Add($"{methodRef.DeclaringType.FullName}.{methodRef.Name}() - {GetSuspiciousMethodDescription(methodRef)}");
                }
            }
            
            return result.Distinct().ToList();
        }
        
        private string GetFieldVisibility(FieldDefinition field)
        {
            if (field.IsPublic) return "public";
            if (field.IsPrivate) return "private";
            if (field.IsFamily) return "protected";
            if (field.IsFamilyOrAssembly) return "protected internal";
            if (field.IsAssembly) return "internal";
            return "private"; // Default
        }

        private string GetPropertyVisibility(PropertyDefinition prop)
        {
            // Determine overall visibility based on accessors
            var getAccess = prop.GetMethod;
            var setAccess = prop.SetMethod;

            bool isPublic = (getAccess?.IsPublic ?? false) || (setAccess?.IsPublic ?? false);
            if (isPublic) return "public";

            bool isProtectedInternal = (getAccess?.IsFamilyOrAssembly ?? false) || (setAccess?.IsFamilyOrAssembly ?? false);
            if (isProtectedInternal) return "protected internal";

            bool isProtected = (getAccess?.IsFamily ?? false) || (setAccess?.IsFamily ?? false);
            // If one is protected and the other is internal, treat as protected internal for simplicity, covered above.
            // If one is protected and the other is private/missing, it's protected.
            if (isProtected) return "protected"; 

            bool isInternal = (getAccess?.IsAssembly ?? false) || (setAccess?.IsAssembly ?? false);
            if (isInternal) return "internal";

            // If we reach here, it means any accessors present are private, or there are no accessors that make it more visible.
            // If at least one accessor exists and is private, it's private. 
            // If no accessors, it's unusual but default to public as per C# auto-property if no visibility specified (though here we list existing ones).
            if ((getAccess != null && getAccess.IsPrivate) || (setAccess != null && setAccess.IsPrivate) ) return "private";
            if (getAccess == null && setAccess == null) return "public"; // No accessors, unusual for Cecil-parsed existing property

            return "public"; // Fallback, should be rare
        }

        private string GenerateClassStructure(TypeDefinition typeDef, string highlightMethodName = null)
        {
            if (typeDef == null) return string.Empty;

            var sb = new StringBuilder();
            sb.AppendLine($"// Class Outline: {typeDef.FullName}");
            if (typeDef.BaseType != null && typeDef.BaseType.FullName != "System.Object")
            {
                sb.AppendLine($"// Inherits from: {typeDef.BaseType.FullName}");
            }
            if (typeDef.HasInterfaces)
            {
                foreach(var ifaceInfo in typeDef.Interfaces)
                {
                    sb.AppendLine($"// Implements: {ifaceInfo.InterfaceType.FullName}");
                }
            }

            string typeKind = "class"; // Default
            if (typeDef.IsInterface) typeKind = "interface";
            else if (typeDef.IsEnum) typeKind = "enum";
            else if (typeDef.IsValueType) typeKind = "struct"; // struct but not enum
            
            sb.AppendLine($"public {typeKind} {typeDef.Name} // Simplified declaration");
            sb.AppendLine("{");

            // Fields
            var fields = typeDef.Fields.ToList();
            if (fields.Any())
            {
                sb.AppendLine("  // Fields");
                foreach (var field in fields.Take(10))
                {
                    sb.AppendLine($"  {GetFieldVisibility(field)} {(field.IsStatic ? "static " : "")}{field.FieldType.Name} {field.Name};");
                }
                if (fields.Count > 10) sb.AppendLine($"  // ... and {fields.Count - 10} more fields");
                sb.AppendLine();
            }

            // Properties
            var properties = typeDef.Properties.ToList();
            if (properties.Any())
            {
                sb.AppendLine("  // Properties");
                foreach (var prop in properties.Take(10))
                {
                    string accessors = "{ ";
                    if (prop.GetMethod != null) accessors += "get; ";
                    if (prop.SetMethod != null) accessors += "set; ";
                    accessors += "}";
                    // Determine static based on if either accessor is static
                    bool isStatic = (prop.GetMethod?.IsStatic ?? false) || (prop.SetMethod?.IsStatic ?? false);
                    sb.AppendLine($"  {GetPropertyVisibility(prop)} {(isStatic ? "static " : "")}{prop.PropertyType.Name} {prop.Name} {accessors}");
                }
                if (properties.Count > 10) sb.AppendLine($"  // ... and {properties.Count - 10} more properties");
                sb.AppendLine();
            }

            // Methods (excluding constructors, getters, setters for brevity in this outline)
            var methods = typeDef.Methods.Where(m => !m.IsConstructor && !m.IsSpecialName).ToList(); // IsSpecialName filters getters/setters like get_Property, set_Property
            if (methods.Any())
            {
                sb.AppendLine("  // Methods (signatures only, excluding constructors/property accessors)");
                foreach (var method in methods.Take(15))
                {
                    string marker = (highlightMethodName != null && method.Name == highlightMethodName) ? " // <<< Method with finding" : "";
                    sb.AppendLine($"  {GetMethodVisibility(method)} {(method.IsStatic ? "static " : "")}{method.ReturnType.Name} {method.Name}({GetMethodParameters(method)});{marker}");
                }
                if (methods.Count > 15) sb.AppendLine($"  // ... and {methods.Count - 15} more methods");
            }
            sb.AppendLine("}");
            return sb.ToString();
        }
        
        private string GetMethodVisibility(MethodDefinition method)
        {
            if (method.IsPublic) return "public";
            if (method.IsPrivate) return "private";
            if (method.IsFamily) return "protected";
            if (method.IsFamilyOrAssembly) return "protected internal";
            return "internal";
        }
        
        private string GetMethodParameters(MethodDefinition method)
        {
            var parameters = new List<string>();
            foreach (var param in method.Parameters)
            {
                parameters.Add($"{param.ParameterType.Name} {param.Name}");
            }
            
            return string.Join(", ", parameters);
        }
        
        private string FormatInstruction(Instruction instruction)
        {
            var opCode = instruction.OpCode.Name;
            
            // Skip nop instructions to reduce noise
            if (opCode == "nop")
                return string.Empty;
                
            var operand = FormatOperand(instruction.Operand);
            return $"{opCode} {operand}".Trim();
        }
        
        private string FormatOperand(object operand)
        {
            if (operand == null)
                return string.Empty;
                
            if (operand is MethodReference methodRef)
                return $"{methodRef.DeclaringType.Name}.{methodRef.Name}()";
                
            if (operand is TypeReference typeRef)
                return typeRef.FullName;
                
            if (operand is FieldReference fieldRef)
                return $"{fieldRef.DeclaringType.Name}.{fieldRef.Name}";
                
            if (operand is string stringValue)
                return $"\"{stringValue}\"";
                
            return operand.ToString();
        }
        
        private string ExtractAssemblyMetadata(string modPath)
        {
            try
            {
                if (!File.Exists(modPath))
                    return string.Empty;
                    
                var sb = new StringBuilder();
                
                var readerParameters = new ReaderParameters
                {
                    ReadWrite = false,
                    InMemory = true,
                    ReadSymbols = false
                };
                
                using var assembly = AssemblyDefinition.ReadAssembly(modPath, readerParameters);
                
                // Basic assembly info
                sb.AppendLine($"- **Assembly Name**: {assembly.Name.Name}");
                sb.AppendLine($"- **Version**: {assembly.Name.Version}");
                
                if (!string.IsNullOrEmpty(assembly.Name.Culture))
                    sb.AppendLine($"- **Culture**: {assembly.Name.Culture}");
                    
                // List of referenced assemblies
                sb.AppendLine("- **Referenced Assemblies**:");
                foreach (var reference in assembly.MainModule.AssemblyReferences.Take(10))
                {
                    sb.AppendLine($"  - {reference.Name} (v{reference.Version})");
                }
                
                if (assembly.MainModule.AssemblyReferences.Count > 10)
                    sb.AppendLine($"  - *and {assembly.MainModule.AssemblyReferences.Count - 10} more...*");
                
                // Custom attributes that might be relevant for security analysis
                var securityRelevantAttributes = assembly.CustomAttributes
                    .Where(attr => 
                        attr.AttributeType.Name.Contains("Security") || 
                        attr.AttributeType.Name.Contains("Permission") ||
                        attr.AttributeType.Name.Contains("Unsafe"))
                    .ToList();
                    
                if (securityRelevantAttributes.Any())
                {
                    sb.AppendLine("- **Security-Related Attributes**:");
                    foreach (var attr in securityRelevantAttributes)
                    {
                        sb.AppendLine($"  - {attr.AttributeType.Name}");
                    }
                }
                
                return sb.ToString();
            }
            catch (Exception ex)
            {
                _logger.Error($"Failed to extract assembly metadata from {modPath}: {ex.Message}");
                return string.Empty;
            }
        }

        public bool SavePromptToFile(string modPath, List<ScanFinding> findings, string outputDirectory)
        {
            try
            {
                var prompt = GeneratePrompt(modPath, findings);
                var modName = Path.GetFileName(modPath);
                Directory.CreateDirectory(outputDirectory);
                var filePath = Path.Combine(outputDirectory, $"{modName}.prompt.md");
                
                File.WriteAllText(filePath, prompt);
                return true;
            }
            catch (Exception ex)
            {
                _logger.Error($"Failed to save prompt to file: {ex.Message}");
                return false;
            }
        }

        private static int GetSeverityRank(string severity)
        {
            return severity.ToLower() switch
            {
                "critical" => 4,
                "high" => 3,
                "medium" => 2,
                "low" => 1,
                _ => 0
            };
        }

        private static string FormatSeverityLabel(string severity)
        {
            return severity.ToLower() switch
            {
                "critical" => "CRITICAL",
                "high" => "HIGH",
                "medium" => "MEDIUM",
                "low" => "LOW",
                _ => severity.ToUpper()
            };
        }
    }
}
